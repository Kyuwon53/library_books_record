# 📚 그림으로 배우는 Http & Network Basic
## 📖 3장 HTTP 정보는 HTTP 메시지에 있다 🔎

HTTP 통신에는 클라이언트에서 서버로 보내는 리퀘스트와 서버에서 클라이언트로 보내는 리스폰스가 있습니다. 이 리퀘스트와 리스폰스가 어떻게 동작하는지 살펴보도록 합시다. 

<br>

### 📍 1. HTTP 메시지 
- HTTP에서 교환하는 정보는 HTTP 메시지라고 불리는데 리퀘스트 측 HTTP 메시지를 ***리퀘스트 메시지**, 리스폰스 측 HTTP 메시지를 **리스폰스 메시지**라고 부른다.
- HTTP 메시지는 크게 구분하면 메시지 헤더와 메시지 바디로 구성되어 있고, 최초에 나타나는 개행 문자(CR+LF)로 메시지 헤더와 메시지 바디를 구분한다

<br>

###### HTTP 메시지 구조
- 메시지 헤더 
  - 서버와 클라이언트가 꼭 처리해야 하는 리퀘스트와 리스폰스 내용과 속성 등
- CR + LF
  - CR (carriage return : 16진수 0x0d)
  - LF (line feed : 16진수 0x0a)
- 메시지 바디
  - 꼭 전송되는 데이터 그 자체

<br>

***

<br>

### 📍 2. 리퀘스트 메시지와 리스폰스 메시지의 구조

<br>

- 리퀘스트 라인 
  - 리퀘스트에 사용하는 메소드와 리퀘스트 URI와 사용하는 HTTP 버전이 포함된다
- 상태 라인
  - 리스폰스 결과를 나타내는 상태 코드와 설명, 사용하는 HTTP 버전이 포함된다
- 헤더 필드
  - 리퀘스트와 리스폰스의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함된다.
  - 일반 헤더 필드, 리퀘스트 헤더 필드, 리스폰스 헤더 필드, 엔티티 헤더 필드 등 4종류가 있다.
- 그 외
  - HTTP의 RFC에는 없는 헤더 필드(쿠키 등)가 포함되는 경우가 있다.


<br>

***

<br>

### 📍 3. 인코딩으로 전송 효율을 높이다

<br>

- HTTP로 데이터를 전송할 경우 그대로 전송할 수도 있지만 전송할 때에 인코딩(변환)을 실시함으로써 전송 효율을 높일 수 있다.
- 전송할 때 인코딩을 하면 다량의 엑세스를 효율 좋게 처리할 수 있다. 
- 단지, 컴퓨터에서 인코딩 처리를 해야 하기 때문에 CPU 등의 리소스는 보다 많이 소비하게 된다. 

<br>

#### 📎 3-1. 메시지 바디와 엔티티 바디의 차이

<br>

- **메시지(message)**
  - HTTP 통신의 기본 단위로 옥텟 시퀀스(Octet sequence, octet은 8비트)로 구성되고 통신을 통해서 전송된다.
- **엔티티(entity)**
  - 리퀘스트랑 리스폰스의 페이로드(payload, 부가물)로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 구성된다.

- HTTP 메시지 바디의 역할은 리퀘스트랑 리스폰스에 관한 엔티티 바디를 운반하는 일이다. 
- 기본적으로 메시지 바디와 엔티티 바디는 같지만 전송 코딩이 적용된 경우에는 엔티티 바디의 내용이 변화하기 때문에 메시지 바디와 달라진다.

<br>

#### 📎 3-2. 압축해서 보내는 콘텐츠 코딩 

<br>

- 메일에 파일을 첨부해서 보낼 경우 같이 용량을 줄이기 위해서 파일을 zip으로 압축하고 나서 첨부해서 보내는 일이 있다. 
- 이를 **콘텐츠 코딩(Content Codings)** 이라고 불리는 기능이 구현되어 있다.
- 콘텐츠 코딩은 엔티티에 적용하는 인코딩을 가리키는데 엔티티 정보를 유지한채로 압축한다.
- 콘텐츠 코딩된 엔티티는 수신한 클라이언트 측에서 디코딩한다. 


<br>

#### 📎 3-3. 분해해서 보내는 청크 전송 코딩

<br>

- HTTP 통신에서는 리퀘스트했었던 리소스 전부에서 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시되지 않는다.
- 사이즈가 큰 데이터를 전송하는 경우에 데이터를 분할해서 조금씩 표시할 수 있다.
- 엔티티 바디를 분할하는 기능을 청크 전송 코딩(Chunked transfer Coding)이라고 부른다.

<br>

- 청크 전송 코딩은 엔티티 바디를 청크(덩어리)로 분해한다.
- 다음 청크 사이즈를 16진수로 사용해서 단락을 표시하고 엔티티 바디 끝에는 "0(CR + LF)"를 기록해둔다.
- 청크 전송 코딩된 엔티티 바디는 수신한 클라이언트 측에서 원래의 엔티티 바디로 디코딩한다.


<br>

***

<br>

### 📍 4. 여러 데이터를 보내는 멀티파트

<br>

- **MIME(Multipurpose Internet Mail Extensions: 다목적 인터넷 메일 확장 사양)** 으로 불리는 메일로 텍스트나 영상, 이미지와 같은 여러 다른 데이터를 다루기 위한 기능을 사용하고 있다. 
- MINE는 이미지 등의 바이너리 데이터를 아스키(ASCII) 문자열에 인코딩하는 방법과 데이터 종류를 나타내는 방법 등을 규정하고 있다. 
- MIME의 확장 사양에 있는 멀티파트(Multipart)라고 하는 여러 다른 종류의 데이터를 수용하는 방법을 사용하고 있는 것이다. 
- HTTP도 멀티파트에 대응하고 잇어 **하나의 메시지 바디 내부에 엔티티를 여러 개 포함시켜 보낼 수 있다.**
- 주로 이미지나 텍스트 파일 등을 업로드할 때 사용되고 있다.

<br>

- **multipart/form-data**
  - Web 폼으로부터 **파일 업로드**에 사용된다.
- **multipart/byteranges**
  - 상태 코드 206(Partial Content) 리스폰스 메시지가 복수 범위의 내용을 포함하는 때에 사용된다. 

<br>

- HTTP 메시지로 멀티파트를 사용할 때에는 Content-type 헤더 필드를 사용한다. 
- 멀티파트 각각의 엔티티를 구분하기 위해 `"boundary"` 문자열을 사용한다
- 각 엔티티의 선두에는 `"boundary"` 문자열 앞에 `"--"`를 삽입한다.
- 멀티파트의 마지막에는 그 문자열의 마지막 부분에 `"--"`를 삽입해서 마무리한다. 
- 멀티파트는 파트마다 헤더 필드가 포함된다.
- 파트의 중간에 멀티파드를 만드는 것과 같이 파트를 내부에 포함할 수도 있다. 


<br>

***

<br>

### 📍 5. 일부분만 받는 레인지 리퀘스트

<br>

- 다운로드 중에 커넥션이 끊어지게 되면 처음부터 다시 다운로드를 해야 했기 때문에 이러한 문제를 해결하기 위해서 일반적인 **리줌(resume)**이라는 기능이 필요하게 되었다.
- 리줌을 통해 이전에 다운로드를 한 곳에서부터 다운로드를 재개할 수 있다. 
- 이 기능을 실현하기 위해서는 엔티티의 범위를 지정해서 다운로드를 할 필요가 있다.
- 범위를 지정하여 리퀘스트 하는 것을 **레인지 리퀘스트(Range Request)**라고 부른다.
- 레인지 리퀘스트를 사용하면 전체 10,000 바이트 정도 크기의 리소스에서 5,001~10,000 바이트의 범위(바이트 레인지) 만을 리퀘스트 할 수 있다.
- 레인지 리퀘스트를 할 때에는 Range 헤더 필드를 사용해서 리소스의 바이트 레인지를 지정한다. 
- 레인지 리퀘스트에 대한 리스폰스는 상태 코드 `206 Partial Content` 라는 리스폰스 메시지가 되돌아온다.
- 복수 범위의 레인지 리퀘스트에 대한 리스폰스는 `multilpart/byteranges`로 리스폰스가 되돌아온다.
- 서버가 레인지 리퀘스트에 지원하지 않는 경우에는 상태 코드 `200 OK`라는 리스폰스 메시지로 완전한 엔티티가 되돌아온다.


<br>

***

<br>

### 📍 6. 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션

<br>

- 같은 콘텐츠(내용)이지만 여러 개의 페이지를 지닌 웹 페이지가 있다.
- 서로 다른 언어를 주로 사용하는 브라우저가 같은 URI에 엑세스할 때에 각각 영어판 웹 페이지와 한국어판 웹 페이지를 표시한다.
- 이와 같은 구조를 콘텐츠 네고시에이션(Content Negotiation)이라고 부른다.
- 콘텐츠 네고시에이션이란 클라이언트와 서버가 제공하는 리소스의 내용에 대해서 교섭하는 것이다.
- 클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조
- 제공하는 리소스를 언어와 문자 세트, 인코딩 방식 등 을 기준으로 판단하고 있다. 
- 판단 기준은 리퀘스트 메시지에 포함된 다음과 같은 리퀘스트 헤더 필드이다. 

<br>

##### 서버 구동형 네고시에이션(Server-driven Negotiation)
- 서버 측에서 콘텐츠 네고시에이션을 하는 방식
- 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해서 자동적으로 처리를 한다.
- 브라우저가 보내는 정보를 근거로 하기 때문에 유저에게 정말로 적절한 것이 선택되었다고 할 수 없다. 

<br>

##### 에이전트 구동형 네고시에이션(Agent-driven Negotiation)
- 클라이언트 측에서 콘텐츠 네고시에이션을 하는 방식
- 브라우저에 표시된 선택지 중에서 **유저가 수동으로 선택**한다.

<br>

##### 트랜스페어런트 네고시에이션(Transparent Negotiation)
- 서버 구동형과 에이전트 구동형을 혼합한 것으로 서버와 클라이언트가 각각 콘텐츠 네고시에이션을 하는 방식

# 📚 자바와 JUnit을 활용한 실용주의 단위 테스트 
## 📖 3부 더 큰 설계 그림

단위 테스트는 단지 '설계'라고 하는 더 큰 그림의 일부에 불과하다. 시스템을 개발하면서 코드 설계를 깔끔하게 유지하고 싶을 것읻. 효과적으로 리팩토링하기 위해 반대로 좋고 커다란 설계가 어떤 모습인지 이해할 필요가 있다. 

## 🔎 9장 더 큰 설계 문제 

중복된 코드 조각이 늘면 유지 보수 비용도 증가하고 변경에 대한 리스크도 함께 늘어난다. 그래서 시스템에 있는 중복의 양을 최소화하려고 한다. 

낮은 중복성과 높은 명확성이라는 두 가지 목표를 합리적인 비용과 놀라운 투자 수익률로 달성할 수 있다. 단위 테스트를 만들면 이러한 목표에 도달할 수 있다는 것이다. 

<br>

### 📍 1. Profile 클래스와 SRP

어떤 클래스에 대해 단일 책임을 강조하면 변경으로 인한 리스크는 줄어든다. 클래스에 더 많은 책임이 존재할수록 클래스에 있는 코드를 변경할 때 기존의 다른 동작들을 깨기 쉽다. 더 작고 집중화된 클래스는 다른 맥락에서도 가치를 제공할 수 있다. 바로 재활용이다. 반대로 다수의 책임을 가진 매우 큰 클래스는 다른 맥락에서 사용되기 어렵다. 

#### SOLID 클래스의 설계 원칙 

- 단일 책임 원칙([S]RP): 클래스는 변경할 때 한 가지 이유만 있어야 한다. 클래스는 작고 단일 목적을 추구한다. 
- 개방 패쇄 원칙([O]CP): 클래스는 확장에 열려 있고 변경에는 닫혀 있어야 한다. 기존 클래스의 변경을 최소화해야 한다. 
- 리스코프 치환 원칙([L]SP): 하위 타입은 반드시 상위 타입을 대체할 수 있어야 한다. 클라이언트 입장에서 오버라이딩한 메서드가 기능성을 깨면 안 된다. 
- 인터페이스 분리 원칙([I]SP): 클라이언트는 필요하지 않는 메서드에 의존하면 안 된다. 커다란 인터페이스를 다수의 작은 인터페이스로 분할하라
- 의존성 역전 원칙([D]IP): 고수준 모듈은 저수준 모듈을 의존해서는 안 된다. 둘 다 추상클래스에 의존해야 한다. 추상 클래스는 구체 클래스에 의존해서는 안 된다. 구체 클래스는 추상 클래스에 의존해야 한다. 

<br>

### 📍 2. 새로운 클래스 추출 

클래스를 설계할 때 개념에 매핑하되 구체적인 생각에는 매핑하지 마라. 

설계는 코드를 변경하는 모든 곳에 존재한다. 단지 클래스 수준의 상호 작용이 아니라 유지 보수의 모든 측면에 집중하라. 

<br>

### 📍 3. 명령-질의 분리 

어떤 값을 반환하고 부작용을 발생시키는 (시스템에 있는 어떤 클래스 혹은 엔터티의 상태 변경) 메서드는 명령-질의 분리 원칙을 위반한다. 이 원칙에 따르면 어떤 메서드는 명령을 실행(부작용을 생성하는 어떤 작업을 함)하거나 질의에 대답(어떤 값 반환)할 수 있으며, 두 작업을 모두하면 안 된다. 

질의 메서드가 객체 상태를 바꾸면 그 메서드를 두 번 호출하는 것(어떤 이유에서 같은 질문을 두 번 하는 것)이 불가능할 수도 있다. 혹은 두번째 호출하면 바라지 않는 방향으로 객체 상태가 변질될 수도 있다. 

명령-질의 분리 원칙을 위반하는 전통적인 예제는 `java.util.Iterator` 인터페이스에 있다. 

<br>

### 📍 4. 단위 테스트의 유지 보수 비용

리팩토링은 코드 동작을 변경하지 않고 코드 구현을 바꾸는 활동이다. 테스트는 그 동작을 반영한다. 
하지만 현실에서는 클래스 동작을 변경하고 있다. 적어도 클래스의 인터페이스를 통해 클래스 동작을 노출하는 관점에서 말이다.

결함이 거의 없는 코드를 갖는 이점과 다른 코드가 깨질 것을 걱정하지 않으면서도 코드를 변경할 수 있는 이점, 그리고 코드가 정확히 어떻게 동작하는지 알 수 있는 이점(코드를 깊이 파고들어 무엇이 잘못되었는지 추측하느라 많은 시간을 소모하지 않고)을 이야기 했다..

다 많은 테스트가 동시에 깨질수록 더욱어 많은 설계 문제가 있다. 

<br>

#### 🔑 4-1 자신을 보호하는 방법

코드 중복은 가장 큰 설계 문제이다. 테스트 자체의 관점에서 여러 테스트에 걸친 코드 중복은 두 가지 문제가 있다. 

1. 테스트를 따르기가 어려워진다. 
2. 작은 코드 조각들을 단일 메서드로 추출하면 그 코드 조각들을 변경해야 할 때 미치는 영향을 최소화할 수 있다. 
  - 다수의 장소에 흩어진 테스트를 수정하기보다 단일 장소를 수정하는 것이 훨씬 좋다. 

단위 테스트를 설정하는 데 코드가 몇 줄 혹은 수십 줄 필요하다면 그것은 시스템 설계에 문제가 있다는 것이다. 
SRP를 위반하면 클래스는 점점 커지고, 다른 클래스에 대한 의존성이 커지고, 테스트를 설정하는 데 더 많은 노력이 요구된다. 커다란 클래스를 분할하라. 

`private` 메서드(구현 세부 사항)를 테스트하려는 충동은 클래스가 필요 이상으로 커졌다는 또 다른 힌트이다. 
`private` 메서드가 자꾸 늘어나면 내부 동작을 새 클래스로 옮기고 `public`으로 만드는 것이 좋다. 

**시스템 설계 및 코드 품질이 낮아질수록 단위 테스트의 유지 보수 비용은 증가한다.**

<br>

#### 🔑 4-2 깨진 테스트 고치기 

코드를 새로운 클래스들로 추출하면 작성한 테스트가 좀 더 직관적이고 작성하기 쉬워진다. 또 테스트를 작성하기 쉬워지면 더 많은 순열을 커버하는 경향이 있다. 

`private` 메서드를 새로운 클래스의 `public` 메서드로 이동하면 그 클래스들이 일반적으로 테스트 커버리지가 충분하지 않음을 발견할 것이다. 

메서드가 `public`이 되면 여러분 업무는 그에 대한 테스트를 작성하여 새롭게 노출된 동작을 문서화해 두는 것이다. 

<br>

### 📍 5. 다른 설계에 관한 생각들

여러 클래스에 구현 상태가 흩어져 있을 때의 코드 냄새를 기능의 산재하고 한다. 


중복된 반복문은 구현이 동작하기는 하지만 성능 저하 요인이 되고, 이러한 반복이 필요한 다수의 메서드에 코드 중복이 발생할 수 있다. 이때는 방문자 패턴(Visitore pattern)을 고려할 필요가 있다. 이 패턴은 모든 것을 하느라 얽혀 있는 반복문 덩어리로 코드를 되돌리지 않고도 문제를 해결해 준다. 

시스템 설계에 대해 비판적인 눈을 유지하고 최상의 설계는 없다는 것을 명심하라. 시스템을 깨끗하게 하는 책임은 결코 끝이 없다. 

<br>

### 📍 6. 마치며

**설계를 지속적으로 개선해 나가는 자신감을 키우기 위해 단위 테스트의 커버리지를 높여라**

기꺼이 새롭고 작은 클래스들과 메서드들을 만들어라. 유연한 설계는 더 작고 잘 조직된 구성 요소로 시작된다. 

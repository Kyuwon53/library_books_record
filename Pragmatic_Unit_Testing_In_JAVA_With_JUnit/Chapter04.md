# 📚 자바와 JUnit을 활용한 실용주의 단위 테스트 
## 📖 1부 단위 테스트의 기초 
## 🔎 4장 테스트 조직

단위 테스트를 어떻게 시작할지 시간을 들여 생각해 보는 과정이 필요하다. 테스트 코드를 잘 조직하고 구조화할 수 있는 JUnit 기능을 소개한다. 

- 준비-실행-단언을 사용하여 테스트를 가시적이고 일관성 있게 만드는 방법
- 메서드를 테스트하는 것이 아니라 동작을 테스트하여 테스트 코드의 유지 보수성을 높이는 방법 
- 테스트 이름의 중요성
- `@Before`와 `@After` 애너테이션을 활용하여 공통 초기화 및 정리 코드를 설정하는 방법
- 거슬리는 테스트를 안전하게 무시하는 방법 

<br>

### 📍 1. AAA로 테스트 일관성 유지

테스트 코드를 가시적으로 준비, 실해, 단언 부분으로 조직하는 것을 **트리플-A(AAA)**라고 한다. 
AAA는 앞으로 작성할 모든 테스트 코드에 해당한다. 

  - **준비(Arrange)**: 테스트 코드를 실행하기 전에 시스템이 적절한 상태에 있는지 확인한다. 
    - 객체들을 생성하거나 이것과 의사소통하거나 다른 API를 호출하는 것 등
    - 시스템이 필요한 상태로 있다면 준비 상태를 생략하기도 한다. 
  - **실행(Act)**: 테스트 코드를 실행한다. 
    - 보통은 단일 메서드를 호출한다. 
  - **단언(Assert)**: 실행한 코드가 기대한 대로 동작하는지 확인한다. 
    - 실행한 코드의 반환값 혹은 그 외 필요한 객체들의 새로운 상태를 검사한다. 
    - 테스트한 코드와 다른 객체들 사이의 의사소통을 검사한다. 
 
 테스트의 각 부분을 구별하는 빈 줄은 전체 테스트 코드를 훨씬 빠르게 이해하는 데 필수적인 가시적 도구이다. 

  - **사후(After)**: 테스트를 실행할 때 어떤 자원을 할당했다면 잘 정리(clean up)되었는지 확인해야 한다. 

<br>

### 📍 2. 동작 테스트 vs 메서드 테스트 

테스트를 작성할 때는 클래스 동작에 집중해야 하며 개별 메서드를 테스트한다고 생각하면 안 된다. 

단위 테스트를 작성할 때는 먼저 **전체적인 시각**에서 시작해야 한다. 개별 메서드를 테스트하는 것이 아니라 **클래스의 종합적인 동작**을 테스트해야 한다. 

<br>

### 📍 3. 테스트와 프로덕션 코드의 관계 

JUnit 테스트는 검증 대상인 프로덕션 코드와 같은 프로젝트에 위차할 수 있다. 하지만 테스트는 주어진 프로젝트 안에서 프로덕션 코드와 분리해야 한다. 프로덕션( 테스트 대상으로 테스트 대상 시스템이라고도 함)를 배포할 것이지만 테스트는 일밙거으로 그 뒤에 존재한다. 

- 테스트 코드는 프로덕션 시스템 코드를 의존하지만, 그 반대는 해당하지 않는다. 프로덕션 코드는 테스트 코드의 존재를 모른다.
- 더 많은 단위 테스트를 작성할수록 설계를 변경했을 때 테스트 작성이 훨씬 용이해지는 경우가 늘어날 것이다. 

<br>

#### 🔑 3-1 테스트와 프로덕션 코드 분리 

테스트 배포 여부를 고려하기보다 테스트를 프로덕션 소스와 같은 프로젝트에 넣을지 결정해야 한다. 

- **테스트를 프로덕션 코드와 같은 디렉터리 및 패키지에 넣기**
  - 실제 배포할 때 테스트 코드를 걷어 내는 스크립트가 필요하다
  - 클래스 이름으로 구별하거나 테스트 클래스 여부를 식별할 수 있는 리플랙션 코드를 작성해야 한다. 

- **테스트를 별도 디렉터리로 분리하지만 프로덕션 코드와 같은 패키지에 넣기**
  - 대부분의 회사에서 이것을 선택한다. 
  - `test` 디렉터리의 구조가 `src` 디렉터리를 반영하기 때문에 각 테스트는 검증하고자 하는 대상 클래스와 동일한 패키지를 가진다. 
  - 테스트 클래스는 패키지 수준의 접근 권한을 가진다. 

- **테스트를 별도의 디렉터리와 유사한 패키지에 유지하기**
  - 테스트 코드를 프로덕션 코드의 패키지와 다르게 하면 공개(public) 인터페이스만 활용하여 테스트 코드를 작성한다. 
  - 많은 개발자가 의도적으로 설계할 때 이 정책을 채택한다. 

<br>

#### 🔑 3-2 내부 데이터 노출 vs 내부 동작 노출 

- 비공개 코드를 호출하는 테스트는 그 자체로 구현 세부 사항과 결속하게 된다.
  - 이러한 세부 사항이 변경되면 기술적으로 공개적인 행동이 그대로라고 해도 테스트는 깨질 수 있다. 
- 내부의 세부 사항을 테스트하는 것은 저품질로 이어질 수도 있다.
  - 코드의 작은 변화가 수많은 테스트를 깨면 (테스트 코드가 과도하게 내부적인 구현 사항을 알고 있기 때문에) 리팩터링을 꺼리게 되고 리팩터링이 줄어들수록 코드 베이스는 빠르게 퇴화한다. 
- 외부 세상으로 필드를 공개하지 않을수록 좀 더 편안해진다. 
  - 테스트를 위해 내부 데이터를 노출하는 것은 테스트와 프로덕션 코드 사이에 과도한 결합을 초래한다. 
- 내부 행위를 테스트하려는 충동이 든다면 설계에 문제가 있는 것이다. 
  - 묻혀 있는 수많은 흥미로운 행동은 거의 **단일 책임 원칙(SRP, Single Responsibility Principle)**을 어기게 된다. 
    - **SRP**는 어떤 클래스가 작고 단일 목적을 가져야 함을 의미하며, 가장 좋은 해결책은 흥미로운 private 메서드를 추출하여 다른 클래스로 이동하는 것이다. 그렇게 하면 그 클래스의 유용한 public 메서드가 된다. 

<br>

### 📍 4. 집중적인 단일 목적 테스트의 가치

- 다수의 케이스를 별도의 JUnit 테스트 메서드로 분리하라. 각각에는 검증하는 동작을 표현하는 이름을 붙이세요.

#### 테스트를 분리
  - 단언이 실패했을 때 실패한 테스트 이름이 표시되기 때문에 어느 동작에서 문제가 있는지 빠르게 파악할 수 있다.
  - 실패한 테스트를 해독하는 데 필요한 시간을 줄일 수 있다. 
    - JUnit은 각 테스트를 별도의 인스턴스로 실행하기 때문이다. 
      - 현재 실패한 테스트에 대해 다른 테스트의 영향을 제거할 수 있다. 
  - 모든 케이스가 실행되었음을 보장할 수 있다. 단언이 실패하면 현재 테스트 메서드는 중단한다.
    - 단언 실패는 `java.lang.AssertionError`를 던지기 때문이다. (JUnit은 이것을 잡아 테스트를 실패로 표시한다)
    - 단언 실패 이후의 테스트 케이스는 실행되지 않는다. 
    
<br>

### 📍 5. 문서로서의 테스트 

단위 테스트는 우리가 만드는 클래스에 대한 지속적이고 믿을 수 있는 문서 역할을 해야 한다. 테스트는 코드 자체로 쉽게 설명할 수 없는 가능성들을 알려준다. 주석으로 적어 놓았을 많은 내용을 보충한다. 

<br>

#### 🔑 5-1 일관성 있는 이름으로 테스트 문서화 

테스트 케이스를 단일 메서드로 결합할수록 테스트 이름 또한 일반적이고 의미를 잃어 간다. 
좀 더 작은 테스트로 이동할수록 각각은 분명한 행동에 집중한다. 테스트하려는 맥락을 제안하기보다는 어떤 맥락에서 일련의 행동을 호출했을 때 어떤 결과가 나오는지를 명시해라.  

##### 이름 짓기
- doingSomeOperationGeneratesSomeResult
  - (어떤 동작을 하면 어떤 결과가 나온다.)
- someResultOccursUnderSomeCondition
  - (어떤 결과는 어떤 조건에서 발생한다.)

**행위 주도 개발(BDD, Behavior-Driven Development)**에서 말하는 **given-when-then** 같은 양식을 사용할 수도 있다. 
- givenSomeContextWhenDoingSomeBehaviorThenSomeResultOccurs
  - (주어진 조건에서 어떤 일을 하면 어떤 결과가 나온다.)

**given-when-then**이라는 테스트 이름은 읽기에 길고 복잡할 수 있다. 보통은 **givenSomeContext** 부분은 제거하여 테스트 독자가 너무 많은 일을 하지 않도록 한다. 

- whenDoingSomeBehaviorThenSomeResultOccurs
  - (어떤 일을 하면 어떤 결과가 나온다.)

어느 형식이든 **일관성**을 유지하는 것이 중요하다. 주요 목표는 테스트 코드를 다른 사람에게 의미 있게 만드는 것이다. 

<br>

#### 🔑 5-2 테스트를 의미 있게 만들기 

- 테스트 이름을 개선
- 지역 변수 이름 개선
- 햄크레스트 단언 사용
- 커다란 테스트를 작게 나누어 집중적인 테스트 만들기
- 테스트 군더더기들을 도우미 메서드와 `@Before` 메서드로 이동

**테스트 이름과 코드를 재작업하여 부가적으로 주석을 넣지 않고도 스토리를 알 수 있도록 만들어라**
    
<br>

### 📍 6. `@Before`와 `@After` (공통 초기화와 정리) 더 알기 

연관된 행동 집합에 대해 더 많은 테스트를 추가하면 상당한 테스트 코드가 같은 초기화 부분을 가진다는 것을 발견할 수 있다. `@Before` 메서드를 활용하면 중복된 코드로 유지 보수 악몽에 빠지는 것을 막을 수 있다. 

- JUnit은 소스 코드에 있는 것과는 무관한 순서로 테스트 메서드를 실행한다. 
- `@Before` 메서드는 매번 테스트 메서드 실행에 앞서 실행된다. 
- 초기화 필요가 늘어날 수 있다. 이들 동작을 단일 `@Before` 메서드로 결합하기보다 `@Before` 메서드를 여러 개로 분할한다.

- 다수의 `@Before` 메서드가 있을 때 JUnit은 어떤 실행 순서를 보장하지 않는다.
  - 일정한 순서가 필요하다면 단일 `@Before` 메서드로 결합하여 순서대로 실행되도록 해야 한다.

- 어떤 `@Before` 메서드는 필요한 만큼의 초기화 코드를 넣으면 된다.
  - `@Before` 메서드는 클래스에 있는 모든 테스트에 적용되며, 그 클래스에 있는 모든 테스트에 앞서 실행되어야 하는 코드만 넣어야 한다. 

매우 희귀한 경우로 `@After` 메서드가 필요할 수 있다. 
- `@After` 메서드는 클래스에 있는 각 테스트를 한 후에 실행되며, 테스트가 실패하더라도 실행된다. 
  - `@After` 메서드는 테스트에 발생하는 부산물들을 정리하는 역할을 한다. 

<br>

#### 🔑 6-1 BeforeClass와 AfterClass 애너테이션

보통 테스트 수준의 초기화(`@Before`)면 충분하다. 매우 드문 경우에만 테스트 클래스 수준의 초기화인 `@BeforeClass`가 필요하다. 이것은 클래스에 있는 어떤 테스트를 처음 실행하기 전에 한 번만 실행된다.
    
<br>

### 📍 7. 녹색이 좋다: 테스트를 의미 있게 유지

실패하면 곧바로 고쳐서 모든 테스트가 항상 통과하도록 해야 한다. '항상 녹색으로'가 프로덕션 코드를 변경해야 할 때 코드에 오류가 없도록 지켜 준다. 

<br>

#### 🔑 7-1 테스트를 빠르게

- **필요하다고 생각하는 테스트만 실행**
- 외부 자원에 접근하는 테스트가 많다면 느려진다. 
- 대부분의 단위 테스트는 매우 빨라야 한다. 
- 견딜 수 있는 만큼 많은 테스트를 실행하라. 

<br>

#### 🔑 7-2 테스트 제외

다수의 실패를 다루는 한 가지 해결책은 문제가 있는 테스트에 집중하고 다른 실패 테스트는 주석 처리하는 것이다. 
JUnit은 주석 처리보다 나은 메커니즘을 제공한다. 즉, `@Ignore` 애너테이션을 달면 된다. 

`@Ignore`의 설명 메시지는 선택 사항이다. 
JUnit 테스트 러너는 한 개 혹은 그 이상의 제외된 테스트를 알려 준다. 
주석 처리를 하면 금방 잊기 때문에 따로 볼 수 있는 것이 좋다. 주석 처리한 상태로 코드 저장소에 커밋하면 표시되지 않은 어느 펜스 기둥에 돈 주머니를 매달아서 묻은 것과 같다. 

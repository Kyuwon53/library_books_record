# 📚 자바와 JUnit을 활용한 실용주의 단위 테스트 
## 📖 3부 더 큰 설계 그림

단위 테스트는 단지 '설계'라고 하는 더 큰 그림의 일부에 불과하다. 시스템을 개발하면서 코드 설계를 깔끔하게 유지하고 싶을 것읻. 효과적으로 리팩토링하기 위해 반대로 좋고 커다란 설계가 어떤 모습인지 이해할 필요가 있다. 

## 🔎 10장 목 객체 사용

목 객체를 도입하여 고통을 주는 협력자에 대한 의존성을 끊는 방법과 항상 존재하는 장애물을 넘을 수 있게 도와주는 도구 활용법을 배우자.

<br>

### 📍 1. 테스트 도전 과제

실제 HTTP 호출을 실행하는 메서드에 대한 테스트 
- 실제 호출에 대한 테스트는 나머지 대다수의 빠른 테스트들에 비해 속도가 느릴 것이다. 
- Nominatim HTTP API가 항상 가용한지 보장할 수 없다. 통제 밖이다. 

API 테스트 버전(아마도 QA 서버에 있는)은 가용성 부분을 통제할 수 있지만 여전히 느리다. 종종 API가 다운되는 귀찮은 일도 벌어진다. 

그 대신 목표에 집중하자. 의존성이 있는 다른 코드와 분리하여 테스트 할 메서드의 로직에 관한 단위 테스트를 원한다. 
HttpImpl 클래스를 신뢰할 수 있다면 남은 것은 HTTP 호출을 준비하는 로직과 그 호출에 대한 HTTP 응답에서 생성되는 Address 객체를 생성하는 로직을 테스트하는 것이다. 

<br>

### 📍 2. 번거로운 동작을 스텁으로 대체

먼저 HTTP 호출에서 반환되는 JSON 응답을 이용하여 객체를 생성하는 로직을 검증하는 데 집중하자. 단지 테스트를 작성하는 용도로 하드코딩한 JSON 문자열을 반환하도록 하자. 테스트 용도로 하드 코딩한 값을 반환하는 구현체를 **스텁(stub)**이라고 한다.

HttpImpl 클래스에 있는 프로덕션 구현 대신에 스텁을 사용하는 방법을 클래스에 알려 주어야 한다. 여기서 의존성 주입 기법을 활용할 것이다. 
이것은 단순히 스텁을 클래스 인스턴스로 전달하거나 그것을 주입하는 것을 의미한다. 
지금은 클래스의 생성자를 이용하여 스텁을 주입하는 방법을 선택한다. 

생성자 의존성 주입을 지원하기 위해 Http 인스턴스를 인자로 하는 생성자를 추가하고 새로운 Http 필드에 할당한다. 

<br>

### 📍 3. 테스트를 지원하기 위한 설계 변경

생성자 주입으로 제한할 필요는 없다. 스텁을 주입하는 다른 방법이 많이 있으며 몇몇은 클래스의 인터페이스를 수정할 필요도 없다. 
생성자 대신 세터 메서드를 사용할 수도 있다. 또 팩토리 메서드를 오버라이드할 수도 있다. 추상 팩토리를 도입할 수도 있고, 심지어는 구글 주스 혹은 스프링처럼 다소 마술 같은 주입을 수행하는 도구를 활용할 수도 있다. 

<br>

### 📍 4. 스텁에 지능 더하기: 인자 검증

목은 의도적으로 흉내 낸 동작을 제공하고 수신한 인자가 모두 정상인지 여부를 검증하는 일을 하는 테스트 구조물이다.


<br>

### 📍 5. 목 도구를 사용하여 테스트 단순화 

똑똑한 스텁을 목으로 변환하기 

- 테스트에 어떤 인자를 기대하는지 명시하기(스텁 자체에 있는 것과 반대)
- `get()` 메서드에 넘겨진 인자들을 잡아서 저장하기
- `get()` 메서드에 저장된 인자들이 기대하는 인자들인지 테스트가 완료될 때 검증하는 능력 지원하기 

이 단계들을 수행하는 목을 생성하는 것은 과도(overkill)하다. 실제로 그리 많은 일을 하지 않아도 된다. 

목을 채용하는 테스트들을 빠르게 만들 수 있도록 하는 범용 도구를 도입하는 것이다. 테스트 코드는 더욱 작아지고 간결하게 우리가 증명하려는 것을 선언할 수 있다. 

```java
Http http = mock(Http.class);
when(http.get(contains("lat=38.000000&lon=-104.000000"))).
    thenReturn(...)
```

첫 번째 문장은 모키토에 Http 인터페이스를 구현하는 목 인스턴스를 합성하라고 이야기한다. 이 목은 은밀하게 모든 자질구레한 추적과 검증 작업을 해 준다.

두 번째 문장은 `org.mockito.Mockito` 클래스에 있는 `when()` 정적 메서드를 호출하여 테스트의 기대 사항들을 설정한다. 
`thenReturn()` 메서드를 호출하여 기대 사항이 충족되었을 때의 처리를 한다. 
즉, 기대 사항이 충족되었을 때 목은 지정된 값을 반환한다. 

테스트의 기대 사항 설정은 실제 테스트보다 먼저 해야 한다. 

<br>

### 📍  6. 마지막 하나의 단순화: 주입 도구 소개 

생성자를 사용하여 목을 대상 클래스에 넘기는 것은 일종의 기법이다. 프로덕션 코드에서 인터페이스를 변경하고 내부 사항을 다른 클래스에 노출하게 된다. 

모키토의 DI

1. `@Mock` 애너테이션을 사용하여 목 인스턴스를 생성한다. 
2. `@InjectMocks` 애너테이션을 붙인 대상 인스턴스 변수를 선언한다. 
3. 대상 인스턴스를 인스턴스화한 후에 `MockitoAnnotations.initMocks(this)`를 호출한다. 

- `@Mock` : 목을 합성하고자 하는 곳의 의미
- `@InjectMocks` 목을 주입하고자 하는 대상을 의미 
- `MockitoAnnotations.initMocks(this)`
  - `this` 인수는 테스트 클래스 자체를 참조
  - 모키토는 테스트 클래스에서 어떤 `@Mock` 애너테이션이 붙은 필드를 가져와서 각각에 대해 목 인스턴스를 합성한다.
    - `org.mockito.Mockito.mock(Http.class)`의 직접 호출과 정확하게 동일한 코드이다.
  - `@InjectMocks` 애너테이션이 붙은 필드를 가져와서 목 객체들을 거기에 주입한다. 

목 객체를 주입하려고 모키토는 먼저 사용할 적절한 생성자를 탐색한다. 아무것도 없으면 적절한 세터 메서드를 탐색한다. 미자막으로 적절한 필드를 찾는다(필드 타입과 매칭되는 것으로 시작)

모키토는 필드를 찾아서 목 인스턴스로 주입해준다. 
필드 수준 주입으로는 더 이상 클라이언트에 객체를 생성자로 넘길 필요가 없다. 그 대신 필드 수준의 기본 구현을 제공한다.

<br>

### 📍 7. 목을 올바르게 사용할 때 중요한 것 

목을 사용한 테스트는 진행하길 원하는 내용을 분명하게 기술해야 한다. 이렇게 하는 한 가지 방법은 연관성이다.
테스트 독자가 코드를 깊이 파지 않아도 이러한 관련성을 쉽게 파악할수록 코드는 더 좋아진다. 

목이 실제 동작을 대신한다는 것을 잊지 마라. 그것들을 안전하게 사용하고 있는지 확인하기 위해 자신에게 몇가지 질문을 할 필요가 있다. 

- 목이 프로덕션 코드의 동작을 올바르게 묘사하고 있는가?
- 프로덕션 코드는 생각하지 못한 다른 형식으로 반환하는가?
- 프로덕션 코드는 예외를 던지는가?
- null을 반환하는가?

이들 각 조건에 대해 다른 테스트가 필요할 수도 있다. 

프로덕션 코드를 직접 테스트하고 있지 않다는 것을 기억하라. 목을 도입하면 테스트 커버리지에서 간극(gap)을 형성할 수 있음을 인지해야 한다. 
실제 클래스의 종단 간 사용성을 보여 주는 적절한 상위 테스트(아마도 통합 테스트)가 있는지 확인하라

**목은 단위 테스트 커버리지의 구멍을 만든다. 통합 테스트를 작성하여 이 구멍을 막아라**

<br>

### 📍 8. 마치며 

테스트는 라이브 서비스, 파일, 데이터베이스, 다른 번거로운 의존성들과 상호 작용할 필요가 없다. 또 적절한 도구를 활용하여 목을 생성하고 주입하는 노력을 최소화할 수 있다. 

테스트를 꾸준하게 리팩토링하지 않으면 큰 그림은 완성되지 않는다. 

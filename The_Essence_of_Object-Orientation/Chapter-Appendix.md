# 객체지향의 사실과 오해: 부록 - 추상화 기법

## 추상화 기법 

**추상화**는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단이다. 
- 도메인에 존재하는 개념들을 `구조화`하고 `단순화`하기 위해 다양한 추상화 기법을 사용
- 특성을 공유하는 객체들을 **동일한 타입**으로 분류하는 것 

### 추상화 기법의 종류 
- **분류와 인스턴스화** 
    - `분류`는 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 
범주를 형성하는 과정이다.
    - 분류의 역은 범주로부터 객체를 생성하는 `인스턴스화` 과정이다. 
    
- **일반화와 특수화**
    - `일반화`는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조
    - `특수화`는 일반화의 역
    
- **집합과 분해**
    - `집합`은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정을 가리킨다. 
    - `분해` : 집합의 반대 과정. 전체를 부분으로 분리하는 과정
    
객체지향의 가장 큰 장점은 동일한 추상화 기법을 프로그램의 분석, 설계, 구현 단계에 걸쳐 일관성 있게 적용할 수 있다는 점이다.

<br>

***

## 분류와 인스턴스화 

### 개념과 범주 

객체를 분류하고 `범주`로 묶는 것은 객체들의 특정 집합에 공통의 `개념`을 적용하는 것을 의미한다. 
    - **개념** : 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어
    - **분류** : 세상에 존재하는 객체에 개념을 적용하는 과정 
        - 분류는 객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함시킨다. 

사람들은 분류를 통해 개별 현상을 하나의 개념으로 다룬다. 
- **객체** : 수많은 개별적인 현상들
- **타입** : 하나의 개념. 객체지향의 세계에서 개념을 가리키는 표준 용어 
- 분류의 역은 타입에 해당하는 객체를 생성하는 과정으로 `인스턴스화` 또는 `예시`라고 한다. 
- `분류`란 객체들을 동일한 타입 또는 범주로 묶는 과정을 의미 
- 객체를 타입의 `인스턴스`라고 한다. 

- 분류는 객체와 타입 간의 관계를 나타낸 것

### 타입 

객체를 타입에 따라 분류하기 위해서는 객체가 타입에 속하는지 여부를 확인할 수 있어야 한다. 


- 심볼: 타입을 가리키는 간략한 이름이나 명칭
- 내연 : 타입의 완전한 정의. 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다.
- 외연 : 타입에 속하는 모든 객체들의 집합 

### 외연과 집합


- 타입의 외연은 타입에 속하는 객체들의 집합으로 표현된다
- 집합은 외연을 가리키는 또 다른 명칭
- 객체들은 동시에 서로 다른 집합에 포함될 수 있다. 

- **단일 분류** : 한 객체가 한 시점에 하나의 타입에만 속하는 것 
- **다중 분류** : 한 객체가 한 시점에 여러 타입에 속할 경우 

대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다. 한 객체는 오직 한 클래스의 인스턴스여야만 하며 동시에 두 개의 
클래스의 인스턴스일 수는 없다. 

- **다중 상속** : 하나의 타입이 다수의 슈퍼타입을 가질 수 있도록 허용하지만 타입 정의를 생략하지 못함 
    - 다중 분류는 타입을 정의하지 않아도 다른 타입의 인스턴스가 되도록 허용한다. 
    
- **동적 분류** : 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우
- **정적 분류** : 객체가 자신의 타입을 변경할 수 없는 경우 
    - 객체의 타입을 변경할 수 없다
    - 우리가 사용하는 대부분의 언어는 `정적 분류`만을 허용한다.
    
### 클래스 

객체지향 프로그래밍 언어를 이용해 타입을 구현하는 가장 보편적인 방법은 `클래스`를 이용하는 것이다. 
    - 클래스는 타입을 구현하는 용도 외에도 코드를 재사용하는 용도로 사용되기도 한다.
    - 인스턴스를 생성할 수 없는 추상 클래스나 인터페이스를 이용해 타입을 구현할 수도 있다. 
    - 클래스는 객체가 공유하는 본질적인 속성을 정의한다. 

<br>

***

## 일반화와 특수화 

### 범주의 계층 

린네의 계층 구조
- 좀 더 세부적인 범주가 계층의 하위
    - 계층의 하위에 위치한 범주는  계층의 상위에 위치한 범주의 `특수화`
- 좀 더 일반적인 범주가 계층의 상위 
    - 계층의 상위에 위치한 범주는 계층의 하위에 위치한 범주의 `일반화`


### 서브타입

객체지향의 세계에서 범주는 개념을 의미하고 개념은 타입을 의미하므로 계층은 타입간의 관계를 의미한다. 

- **슈퍼타입(supertype)** : 어떤 타입이 다른 타입보다 일반적
- **서브타입(subtype)** : 어떤 타입이 다른 타입보다 좀 더 특수 
    - 슈퍼타입은 서브타입의 `일반화`
    - 서브타입은 슈퍼타입의 `특수화`
    
어떤 범주에 속하는 다른 객체가 특정 속성을 가지고 있음을 알게 되면 그 범주와 하위 범주에 속하는 다른 객체도 그 속성을 가지고 
있을 것이라고 추론할 수 있다. 

#### 어떤 타입이 다른 타입의 서브타입이 되기 위한 규칙

- 100% 규칙 
    - 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 한다.
    - 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야 한다.
    
- Is-a 규칙
    - 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다.
    - 일반화 관계를 `is-a 관계`라고 한다.
    

### 상속 

일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 `클래스 간의 상속을 사용하는 것`
- 모든 상속 관계가 일반화 관계인 것은 아니다.
- 일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 `순응`해야 한다는 것
    - 서브타입의 슈퍼타입에 대한 대체 가능성을 의미 
    - 서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 한다. 
    
상속은 코드 중복을 방지하고 공통 코드를 재사용하기 위한 언어적 메커니즘을 제공하는 것이다. 

- **서브타이핑**
    - 서브클래스가 슈퍼클래스를 대체할 수 있는 경우
    - 설계의 유연성이 목표
    - **인터페이스 상속**
    
- **슈퍼클래싱**
    - 서브클래스가 슈퍼클래스를 대체할 수 없는 경우 
    - 코드의 중복 제거와 재사용이 목적
    - **서브클래싱을 구현 상속**
    
## 집합과 분해 

- 집합 : 안정적인 형태의 부분으로부터 전체를 구축하는 행위
    - 전체의 내부로 불필요한 세부 사항을 감춰주기 때문에 `추상화 메커니즘`인 동시에 `캡슐화 메커니즘`이다.
    

- 분해 : 전체를 부분으로 분할하는 행위 
- 전체와 부분 간의 일관된 계층 구조는 재귀적인 설계를 가능하게 한다. 

### 패키지 
 
- 구조를 단순화하기 위해서는 서로 관련성이 높은 클래스 집합을 논리적인 단위로 통합해야 한다.
- 클래스 집합을 하나의 논리적인 단위로 묶는 구성 요소를 `패키지` 또는 `모듈`이라고 한다. 


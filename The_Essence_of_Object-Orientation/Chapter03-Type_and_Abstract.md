# 객체지향의 사실과 오해: 03 타입과 추상화 
> 일단 컴퓨터를 조작하는 것이 추상화를 구축하고, 조작하고, 추론하는 것에 관한 모든 것이라는 것을 깨닫고 나면 (훌륭한) 컴퓨터 프로그램을 작성하기 위한 중요한 전체 조건은 추상화를 정확하게 다루는 능력이라는 것이 명확해진다.
> 
> 핵심은 지도가 당연히 가져야 한다고 생각되는 `정확성`을 버리고 그 `목적`에 집중한 결과다. 

- 현실은 복잡하며 예측 불가능한 혼돈의 덩어리다. 
- 이해하기 쉽고 예측 가능한 수준으로 현실을 분해하고 단순화 
- `추상화`의 목적은 불필요한 부분을 무시함으로써 현실에 존재하는 복잡성을 극복하는 것.
***
## 추상화
- 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법.
    1. 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것
    2. 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것 
    
### 추상화의 목적
    - 복잡성을 이해하기 쉬운 수준으로 단순화하라 
***
### 그룹으로 나누어 단순화하기 
- 객체 : 객체지향 패러다임에서 명확한 경계를 가지고 서로 구별할 수 있는 구체적인 사람이나 사물
- 차이점을 의도적으로 무시하고 공통점만을 취해 개념을 단순화하는 것이 추상화의 일종이다.

<br>   

#### 개념


- 공통점을 기반으로 객체들을 묶기 위한 그릇 
- 개념은 특정한 객체가 어떤 그룹에 속할 것인지를 결정.
- 일반적으로 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념 
- `개념`을 이용하면 객체를 여러 그룹으로 `분류(classification)`할 수 있다.
> 개념은 공통점을 기반으로 객체를 분류할 수 잇는 일종의 체라고 할 수 있다. 
> 
- 추상화의 첫 번째 차원인 일반화를 적용한 결과
 
<br>   

##### 인스턴스( instance)
- 해당 클래스의 구조로 컴퓨터 저장공간에서 할당된 실체를 의미
- 객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일원이 될 때 객체를 그 개념의 `인스턴스`라고 한다.
- 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다.

<br>   

##### 개념의 세 가지 관점

- **심볼(symbol)** : 개념을 가리키는 간략한 이름이나 명칭
  - ex) 트럼프
    

- **내연(intension)** : 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.
    - 개념을 객체에게 적용할 수 있는지 여부를 판단하기 위한 조건 
    - ex) 몸이 납작하고 두 손과 두 발은 네모 귀퉁이에 달려 있는 등장인물
    

- **외연(extension)** : 개념에 속하는 모든 객체의 집합(set)
    - 개념의 `인스턴스`들이 모여 이뤄진 집합
    - ex) 정원사, 병사, 신하, 하트 잭 등등 

<br>   


##### 분류
- 객체에 특정한 개념을 적용하는 작업
- 객체지향의 가장 중요한 개념 중 하나
    - 어떤 객체를 어떤 개념으로 분류할지가 객체지향의 품질을 결정
- 객체를 적절한 개념에 따라 분류한 애플리케이션은 유지보수가 용이하고 변경에 유연하게 대처할 수 있다.
- 개념을 통해 객체를 분류하는 과정은 추상화의 두 가지 차원을 모두 사용 
    1. 개별 객체 간의 차이점은 무시하고 공통점을 취함 => 일반화를 적용 
    2. 공통점 중에서도 중요한 특징 외의 사항은 전적으로 무시 => 불필요한 세부 사항을 제거
    
<br>

***

## 타입
> 타입은 개념이다. 

- 공통점을 기반으로 객체들을 묶기 위한 틀
- 타입이 없다 : 메모리 안의 데이터를 다룰 수 있는 단 하나의 타입만이 존재한다는 것을 의미
  - 일련의 비트열(bit String)로 구성


### 타입 시스템 

<br>

- 메모리 안의 모든 데이터가 비트열로 보임으로써 야기되는 혼란을 방지
- 수행 가능한 작업과 불가능한 작업을 구분함으로써 데이터가 잘못 사용되는 것을 방지 


> 결과적으로 타입 시스템의 목적은 데이터가 잘못 사용되지 않도록 제약사항을 부과하는 것이다. 

<br>

#### 1. 타입은 데이터가 어떻게 사용되느냐

- 데이터가 어떤 타입에 속하는지를 결정하는 것은 데이터에 적용할 수 있는 작업 
  - 어떤 데이터에 어떤 연산자를 적용할 수 있느냐가 그 데이터의 타입을 결정 
  
#### 2. 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다.

- 데이터 타입의 표현은 연산 작업을 수행하기에 가장 효과적인 형태가 선택된다. 

***

## 객체와 타입 
> 객체가 협력을 위해 어떤 책임을 지녀야 하는지를 결정하는 것이 객체지향 설계의 핵심이다.
> 
1. 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동
  - 어떤 객체들이 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류

2. 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다
  - 객체의 행동을 가장 효과적으로 수행할 수만 있다면 객체 내부의 상태를 어떤 방식으로 표현하더라도 무방 

<br>

### 행동이 우선이다. 
동일한 책임을 수행하는 일련의 객체는 동일한 타입에 속한다. 



#### 어떤 객체를 다른 객체와 동일한 타입으로 분류하는 기준은 무엇인가? 
- 객체가 타입에 속한 다른 객체와 동일한 행동을 하기만 하면 된다.
- 객체가 다른 객체와 동일한 데이터를 가지고 있더라도 다른 행동을 한다면 그 객체들은 서로 다른 타입으로 분류

 _**결론적으로 객체의 타입을 결정하는 것은 `객체의 행동`뿐이다.**_

동일한 타입에 속한 객체는 내부의 데이터 표현 방식이 다르더라도 동일한 메시지를 수신하고 처리할 수 있다.    
=> 내부의 표현 방식이 다르기 때문에 동일한 메시지를 처리하는 방식은 서로 다를 수밖에 없다.   
  => `다형성` : 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력

동일한 메시지를 서로 다른 방식으로 처리하기 위해서는 객체들은 동일한 메시지를 수신할 수 있어야 하기 때문에     
결과적으로 `다형적인 객체들은 동일한 타입에 속한다`.  

##### `캡슐화` : 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춰야 한다. 

> 객체를 결정하는 것은 `행동`이다. 데이터는 단지 행동을 따를 뿐이다. 이것이 객체를 객체답게 만드는 가장 핵심적인 원칙이다.
> 

<br>


### 일반화/특수화 관계

<br>

일반화와 특수화는 동시에 일어난다. 일반적이라는 말은 더 포괄적이라는 의미를 내포한다.    
더 특수하다는 것은 일밙거인 개념보다 범위가 더 좁다는 것을 의미한다. 
> 집합의 관점에서 본다면 특수한 개념을 표현하는 트럼프 인간은 좀 더 일반적인 개념을 표현하는 트럼프의 부분 집합이 된다. 
> 

- 객체지향에서 일반화/특수화 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 행동이라는 것. 

일반적 타입이란?    
- 특수한 타입이 가진 모든 행동들 중에서 일부 행동만을 가지는 타입

특수한 타입이란?
- 일반적인 타입이 가진 모든 타입을 포함하지만 거기에 더해 자신만의 행동을 추가하는 타입

=> 일반적인 타입은 특수한 타입보다 더 적은 수의 행동을 가지고 특수한 타입은 일반적인 타입보다 더 많은 수의 행동을 가진다. 
 
즉, 일반적인 타입이 특수한 타입에 속해있다.
  - 고로 특수한 타입은 일반적인 타입의 모든 행동을 동일하게 수행 가능
일반적인 타입이 특수한 타입의 부분집합이라고 할 수 있지만 집합적으로 볼 때 일반적인 타입이 더 큰 크기의 외연 집합을 가진다. 

<br>

### 슈퍼타입과 서브타입

- `슈퍼타입` : 일반적인 타입
- `서브타입` : 특수한 타입 
  - 두 타입 간의 관계는 행동에 의해 결정된다. 
  - 서브타입은 슈퍼타입의 행위와 호환되기 때문에 슈퍼타입을 대체할 수 있어야 한다. 
  - 서브타입은 슈퍼타입의 행위에 추가적으로 특수한 자신만의 행동을 추가하는 것 
    - 슈퍼타입의 행동은 서브타입에게 자동으로 `상속`된다

### 일반화는 추상화를 위한 도구 

중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거시켜 단순하게 만드는 것. 

<br>

## 정적 모델 

### 타입의 목적 
- 시간에 따라 동적으로 변하는 객체의 복잡성때문 
- 타입은 동적으로 변하는 객체를 상태에 복잡성을 부과하는 요소를 제거함으로써 독립적인  정적인 모습으로 객체를 생각 할 수 있게 해준다.
- 결국 타입은 추상화다 .
- 객체의 동적인 특성을 추상화 -> 복잡성을 단순화 

### 동적 모델과 정적 모델

스냅샷(snapshot) : 객체가 특정 시점에 구체적으로 어떤 상태를 가지느냐 
- 객체 다이어그램 (object diagram)이라고도 불림

동적 모델 (dynamic model) : 실제로 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 포착하는 것

타입 모델 (type diagram) : 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것   
=> 객체가 속한 타입의 정적인 모습을 표현하기 때문에 `정적 모델(static model)`이라고 한다. 


### 클래스 

객체지향 프로그래밍 언어에서 `정적인 모델`은 `클래스`를 이용해 구현된다.    
=> 타입을 구현하는 가장 보편적인 방법 : `클래스`
  - 클래스는 단지 타입을 구현할 수 있는 구현 메커니즘 중 하나 
  - 프로토타입 기반의 언어에는 클래스가 존재하지 않는다. 

## 결론
- 객체를 분류하는 기준은 `타입`
- 타입을 나누는 기준은 객체가 수행하는 `행동`
- 객체를 분류하기 위해 타입을 결정한 후 프로그래밍 언어를 이용해 타입을 구형할 수 있는 방법 중 하나가 `클래스`

> 결국 객체지향에서 중요한 것은 동적으로 변하는 객체의 `상태`와 상태를 변경하는 `행위`다. `클래스`는 타입을 구현하기 위해 프로그래밍 언어에서 제공하는 구현 메커니즘이라는 사실을 기억하라. 
> 

<br>





# 📖 3장 this  ✏️

자바스크립트에서 가장 혼란스러운 개념을 고르라고 하면 많은 사람들이 망설임 없이 `this`를 꼽을 것이다. 다른 대부분의 객체지향 언어에서 `this`는 클래스로 생성한 인스턴스 객체를 의미한다.
그러나 자바스크립트에서의 `this`는 어디서든 사용할 수 있다. 상황에 따라 `this`가 바라보는 대상이 달라진다.    

함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 `this`는 실질적으로 이 둘을 구분하는 거의 유일한 기능이다. 

## 🔎 01 상황에 따라 달라지는 this 
- 자바스크립트에서 `this`는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정된다. 
- 실행 컨텍스트는 함수를 호출할 때 생성되므로, 바꿔 말하면 `this`는 **함수를 호출할 때 결정된다**고 할 수 있다. 
- **함수를 어떤 방식으로 호출하느냐에 따라 값이 달라지는 것이다.**

***

<br>

### 📍 1-1 전역 공간에서의 this
- 전역 공간에서 `this`는 전역 객체를 가리킨다. 
- 전역 객체는 자바스크립트 런타임 환경에 따라 다른 이름과 정보를 가지고 있다. 
- 브라우저 환경에서 전역객체는 `window`이고 **Node.js** 환경에서는 `global`이다. 

<br>

- 전역변수를 선언하면 자바스크립트 엔진이 이를 전역객체의 프로퍼티로도 할당한다. 
- 변수이면서 객체의 프로퍼티이기도 한 셈이다. 
- **자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티**로서 동작한다. 
- 사용자가 var 연산자를 이용해 변수를 선언하더라도 실제 자바스크립트 엔진은 어떤 특정 객체의 프로퍼티로 인식하는 것이다. 
- 특정 객체란 바로 실행 컨텍스트의 `LexicalEnvironment`이다. 

<br>

- **전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다**
- 변수 a에 접근하고자 하면 스코프 체인에서 a를 검색하다가 가장 마지막에 도달하는 전역 스코프의 L.E, 즉 전역객체에서 해당 프로퍼티 a를 발견해서 그 값을 반환한다.

<br>

- 처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제가 되는 반면 전역변수로 선언한 경우에는 삭제가 되지 않는다. 
- 전역변수를 선언하면 자바스크립트 엔진이 이를 자동으로 전역객체의 프로퍼티로 할당하면서 추가적으로 해당 프로퍼티의 configurable 속성(변경 및 삭제 가능성)을 **false**로 정의하는 것이다. 
- `var`로 선언한 전역변수와 전역객체의 프로퍼티는 호이스팅 여부 및 configurable 여부에서 차이를 보인다. 

<br>

***

<br>

### 📍 1-2 메서드로서 호출할 때 그 메서드 내부에서의 this

<br>

#### 함수 vs 메서드

- 어떤 함수를 실행하는 방법 중 가장 일반적인 방법 두 가지는 **함수로서 호출하는 경우**와 **메서드로서 호출하는 경우**이다. 
- 함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치로, 이 둘을 구분하는 유일한 차이는 **독립성**에 있다. 
- 함수는 그 자체로 독립적인 기능을 수행하는 반면, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다. 
- 객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작한다. 

<br>

- 원래의 익명한수는 그대로인데 이를 변수에 담아 호출한 경우와 `obj` 객체의 프로퍼티에 할당해서 호출한 경우에 `this`가 달라지는 것이다. 
- `함수로서 호출`과 `메서드로서 호출`을 어떻게 구분할까
  - 함수 앞에 `점(.)`이 있는지 여부만으로 간단하게 구분할 수 있다. 
  - 앞에 점이 없으니 함수로서 호출, 앞에 점이 있으면 메서드로서 호출한 것이다. (대괄호 표기법에 따른 경우에도 메서드로서 호출한 것이다.)
- 어떤 함수를 호출할 때 그 함수 이름(프로퍼티 명) 앞에 객체가 명시돼 있는 경우에는 메서드로 호출한 것이고, 그렇지 않은 모든 경우에는 함수로 호출한 것이다. 

<br>

#### 메서드 내부에서의 this

- `this`에는 호출한 주체에 대한 정보가 담긴다.
- 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체이다. 
- 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 `this`가 되는 것이다. 

<br>

***

<br>

### 📍 1-3 함수로서 호출할 때 그 함수 내부에서의 this

<br>

#### 함수 내부에서의 this
- 어떤 함수를 함수로서 호출할 경우에는 `this`가 지정되지 않는다. 
- 함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않고 개발자가 코드에 직접 관여해서 실행한 것이기 때문에 호출 주체의 정보를 알 수 없는 것이다. 
- `this`가 지정되지 않은 경우 `this`는 전역 객체를 바라본다. 
- 함수에서의 `this`는 전역 객체를 가리킨다.

<br>

#### 메서드의 내부함수에서의 this

- `this` 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고, 오직 해당 함수를 호출하는 구문 앞에 점 또는 대괄호 표기가 있는지 없는지가 관건이다. 

<br>

#### 메서드의 내부 함수에서의 this를 우회하는 방법
- 호출 주체가 없을 때는 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 this를 그대로 상속받아 사용할 수 있다면 좋겠다. 
- 아쉡게도 ES5까지는 자체적으로 내부함수에 this를 상속할 방법이 없지만 다행히 이를 우회할 방법이 없지는 않다. 
- 그중 대표적인 방법은 바로 변수를 활용하는 것이다. 

<br>

#### this를 바인딩하지 않는 함수 
- ES6 함수 내부에서 this가 전역객체를 바라보는 문제를 보완하고자, this를 바인딩하지 않는 화살표 함수를 새로 도입했다.
- 화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있다. 

<br>

***

<br>

### 📍 1-4 콜백 함수 호출 시 그 함수 내부에서의 this

- 함수 A의 제어권을 다른 함수(또는 메서드) B에게 넘겨주는 경우 함수 A를 콜백 함수라 한다. 
- 함수 A는 함수 B의 내부 로직에 따라 실행되며, this 역시 함수 B 내부 로직에서 정한 규칙에 따라 값이 결정된다. 
- `this`가 전역객체를 참조하지만, 제어권을 받은 함수에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조하게 된다. 
- 콜백 함수 내부에서의 this는 전역객체를 참조한다. 
- `addEventListener` 메서드는 콜백 함수를 호출할 때 자신의 `this`를 상속하도록 정의돼 있다. 
  - 메서드명의 `점(.)` 앞부분이 곧 `this`가 되는 것이다. 

<br>

- 콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정하며, 특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라본다.

<br>

***

<br>

### 📍 1-5 생성자 함수 내부에서의 this
- 생성자 함수는 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용하는 함수이다. 
- 객체지향 언어에서는 생성자를 클래스, 클래스를 통해 만든 객체를 인스턴스라고 한다. 
- 공통 속성들을 모아 집합을 정의한 것이 바로 클래스이다. 
- 각 인스턴스들은 공통점들도 있지만 저마다의 개성도 존재할 수 있다. 
- 프로그래밍적으로 `생성자`는 **구체적인 인스턴스를 만들기 위한** 일종의 틀이다. 
- 해당 클래스의 공통 속성들이 미리 준비돼 있고, 여기에 구체적인 인스턴스의 개성을 더해 개별 인스턴스를 만들 수 있다.

<br>

- 자바스크립트는 함수에 생성자로서의 역할을 함께 부여했다. 
- `new` 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작하게 된다. 
- 어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 `this`는 곧 새로 만들 구체적인 인스턴스 자신이 된다. 
- 생성자 함수를 호출(new 명령어와 함께 함수를 호출)하면 우선 생성자의 `prototype` 프로퍼티를 참조하는 `__proto__`라는 프로퍼티가 있는 객체(인스턴스)를 만들고, 미리 준비된 공통 속성 및 개성을 해당 객체(this)에 부여한다. 

<br>

***

<br>

## 🔎 02 명시적으로 this를 바인딩하는 방법 
- this에 별도의 대상을 바인딩하는 방법

<br>

### 📍 2-1 call 메서드

- call 메서드는 메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령이다. 
- call 메서드의 첫 번째 인자를 this로 바인딩하고, 이후의 인자들을 호출할 함수의 매개변수로 한다. 
- 함수를 그냥 실행하면 this는 전역객체를 참조하지만 **call 메서드를 이용하면 임의의 객체를 this로 지정할 수 있다.**
- 메서드에 대해서도 마찬가지로 **객체의 메서드를 그냥 호출하면 this는 객체를 참조하지만 call 메서드를 이용하면 임의의 객체를 this로 지정**할 수 있다. 

<br>

### 📍 2-2 apply 메서드 
- apply 메서드는 call 메서드와 기능적으로 완전히 동일하다
- apply 메서드는 두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점에서만 차이가 있다. 

<br>

### 📍 2-3 call / apply 메서드의 활용
- 키가 0 또는 양의 정수인 프로퍼티가 존재하고 length 프로퍼티의 값이 0 또는 양의 정수인 객체, 즉 배열의 구조와 유사한 객체의 경우(유사배열객체) call 또는 apply 메서드를 이용해 배열 메서드를 차용할 수 있다. 
- slice 메서드는 원래 시작 인덱스값과 마지막 인덱스 값을 받아 시작값부터 마지막값의 앞부분까지의 배열 요소를 추출하는 메서드인데, 매개변수를 아무것도 넘기지 않을 경우에는 그냥 원본 배열의 얕은 복사본을 반환한다. 
- 문자열의 경우 length 프로퍼티가 읽기 전용이기 때문에 원본 문자열에 변경을 가하는 메서드(push, pop, shift, unshift, splice 등)는 에러를 던지며, `concat`처럼 대상이 반드시 배열이어야 하는 경우에는 에러는 나지 않지만 제대로 된 결괄르 얻을 수 없다. 

<br>

#### 생성자 내부에서 다른 생성자를 호출
- 생성자 내부에 다른 생성자와 공통된 내용이 있을 경우 `call` 또는 `apply`를 이용해 다른 생성자를 호출하면 간단하게 반복을 줄일 수 있다. 

<br>

#### 여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 - apply 활용
- 여러 개의 인수를 받는 메서드에게 하나의 배열로 인수들을 전달하고 싶을 때 apply 메서드를 사용하면 좋다. 

- `Math.max / Math.min` 메서드에 `apply`를 적용하면 훨씬 간단해진다. 
- ES6에서는 펼치기 연산자를 이용하면 `apply`를 적용하는 것보다 더욱 간편하게 작성할 수 있다. 
- `call/apply` 메서드는 명시적으로 별도의 this를 바인딩하면서 함수 또는 메서드를 실행하는 훌륭한 방법이지만 오히려 이로 인해 `this`를 **예측하기 어렵게 만들어 코드 해석을 방해한다는 단점이 있다.**

<br>

### 📍 2-4 bind 메서드
- 즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드이다. 
- `bind` 메서드는 함수에 `this`를 미리 적용하는 것과 부분 적용 함수를 구현하는 두 가지 목적을 모두 지닌다. 

<br>

#### name 프로퍼티
- name 프로퍼티에 동사 `bind`의 수동태인 `bound`라는 접두어가 붙는다
- name 프로퍼티가 'bound xxx'라면 이는 곧 함수명이 xxx인 원본 함수에 bind 메서드를 적용한 새로운 함수라는 의미가 된다. 

<br>

#### 상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기 
- 메서드의 내부함수에서 메서드의 this를 그대로 바라보게 하기 위한 방법으로 `self` 등의 변수를 활요한 우회법을 소개했는데, **call, apply 또는 bind 메서드를 이요하면 더 깔끔하게 처리할 수 있다.**
- 콜백 함수를 인자로 받는 함수나 메서드 중에서 기본적으로 콜백 함수 내에서의 this에 관여하는 함수 또는 메서드에 대해서도 bind 메서드를 이용하면 this 값을 사용자의 입맛에 맞게 바꿀 수 있다. 

<br>

### 📍 2-5 화살표 함수의 예외사항

- 화살표 함수는 실챙 컨텍스트 생성 시 this를 바인딩하는 과정이 제외됐다. 
- 이 함수 내부에는 this가 아예 없으며, 접근하고자 하면 스코프체인상 가장 가까운 this에 접근하게 된다. 

<br>

### 📍 2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)
- 콜백 함수를 인자로 받는 메서드 중 일부는 추가로 this로 지정할 객체(thisArg)를 인자로 지정할 수 있는 경우가 있다. 
- 메서드의 `thisArg` 값을 지정하면 콜백 함수 내부에서 this 값을 원하는 대로 변경할 수 있다. 
- 여러 내부 요소에 대해 같은 동작을 반복 수행해야 하는 **배열 메서드**에 많이 포진돼 있다. 

<br>

***

<br>

## 🔎 03 정리

- 명시적 this 바인딩이 없는 한 늘 성립한다
  - 전역공간에서의 this는 전역객체를 참조한다 (브라우저에서는 window, Node.js에서는 global)
  - 어떤 함수를 메서드로서 호출한 경우 this는 메서드 호출 주체(메서드명 앞의 객체)를 참조한다
  - 어떤 함수를 함수로서 호출한 경우 this는 전역객체를 참조한다. 메서드의 내부함수에서도 같다
  - 콜백 함수 내부에서늬 this는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바에 따르며, 정의하지 않은 경우에는 전역객체를 참조한다.
  - 생성자 함수에서의 this는 생성될 인스턴스를 참조한다. 

<br>

- 명시적 this 바인딩
  - `call.apply` 메서드는 this를 명시적으로 지정하면서 함수 또는 메서드를 호출한다
  - bind 메서드는 this 및 함수에 넘길 인수를 일부 지정해서 새로운 함수를 만든다. 
  - 요소를 순회하면서 콜백 함수를 반복 호출하는 내용의 일부 메서드는 별도의 인자로 this를 받기도 한다.


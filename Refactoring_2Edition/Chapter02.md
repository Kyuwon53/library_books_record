# 📚 REFACTORING : 리팩터링 2판
## 📖 2장 리펙터링 원칙 🔎

<br>

### 📍 1 리팩터링 정의

<br>

> 리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

- **함수 추출하기**와 **조건부 로직을 다형성으로 바꾸기**처럼 이름 붙은 리팩터링 기법들이 이 정의에 해당한다. 

> 리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성한다. 

- 지금껏 수많은 사람이 코드를 정리하는 작업을 모조리 `리펙터링`이라고 표현하고 있는데, 앞에서 제시한 정의를 따르면 **특정한 방식에 따라 코드를 정리하는 것**만이 리팩터링이다. 
- 리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다. 
- 개별 리팩터링은 그 자체로 아주 작을 수도 있고, 작은 단계 여러 개가 합쳐진 모습일 수도 있다. 
- 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다. 

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

- 코드베이스를 정리하거나 구조를 바꾸는 모든 작업을 `재구성(restructuring)`이라는 포괄적인 용어로 표현하고, 리팩터링은 재구성 중 특수한 한 형태로 본다. 
- 한 번에 바꿀 수 있는 작업을 수많은 단계로 잘게 나눠서 작업하는 모습을 처음 접하면 리팩터링하는 것이 오히려 비효율적이라고 생각하기 쉽다. 하지만 이렇게 잘게 나눔으로써 오히려 작업을 더 빨리 처리할 수 있다. 
- 단계들이 체계적으로 구성되어 있기도 하고, 무엇보다 디버깅하는 데 시간을 뺏기지 않기 때문이다. 

<br>

- 리팩터링을 정의할 때 `겉보기 동작`이란 표현을 썼다. 리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다는 뜻이다. 완전히 똑같다는 말은 아니다.
- 사용자 관점에서는 달라지는 점이 없어야 한다. 
- 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다. (단, 아무도 발견하지 못한 숨은 버그는 수정해도 괜찮다)
- 리팩터링은 성능 최적화와 비슷하다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다. 단지 목적이 다를 뿐.
- 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 

<br>

### 📍 2 두 개의 모자

<br>

- 기능을 추가할 때는 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 
- 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정한다. 
- 리팩토링할 때는 가능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다. 
- (앞 과정에서 놓친 테스트 케이스를 발견하지 않는 한) 테스트도 새로 만들지 않는다. 부득이 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다. 

- 새 기능을 추가하다 보면 코드 구조를 바꿔야 작업하기 훨씬 쉽겠다는 생각이 들기도 하는데, 리펙토링을 한다. 
- 코드 구조가 어느 정도 개성되면 다시 기능 추가를 이어간다. 
- 추가한 기능이 제대로 작동하는지까지 확인했다면 작성한 코드를 살펴본다. 
- 코드가 이해하기 어렵게 짜였다면 다시 모자를 바꿔 쓰고 리팩토링한다. 
- 전체 작업 시간이 10분 정도로 짧다 해도, 항상 내가 하고 있는 작업이 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다. 

<br>

### 📍 3 리팩터링하는 이유

<br>

- 리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 절대 아니다. 하지만 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다. 

<br>

#### 🎈 리팩터링하면 소프트웨어 설계가 좋아진다. 

<br>

- 리팩터링하지 않으면 소프트웨어의 내부 설계(아키텍처)가 썩기 쉽다. 
- 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.
  - 그러면 코드만 봐서는 설계를 파악하기 어려워진다. 
  - 코드 구조가 무너지기 시작하면 악효과가 누적된다. 
- 코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고, 설계가 부패되는 속도는 더욱 빨라진다.
- 반면 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다. 

<br>

- 중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다. 
- 코드량을 줄인다고 시스템이 빨라지는 것은 아니다. 프로그램의 용량이 속도에 영향을 주는 경우는 별로 없다.
- 코드량이 줄면 수정하는 데 드는 노력은 크게 달라진다.
  - 코드가 길수록 실수 없이 수정하기 어려워진다. 
  - 이해햐야 할 코드량도 늘어난다. 
  - 비슷한 일을 하는 코드가 산재해 있다면 한 부분만 살짝 바꿔서는 시스템이 예상대로 작동하지 않을 수 있다. 
- 중복 코들르 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며, 이는 바람직한 설계의 핵심이다. 

<br>

#### 🎈 리팩터링하면 소프트웨어를 이해하기 쉬워진다. 

<br>

- 프로그래밍은 컴퓨터와 대화하는 것과 같다. 컴퓨터에게 시킬 일을 표현하는 코드를 작성하면, 컴퓨터는 정확히 시킨 대로 반응한다.
- 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 한다. 
- 프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일이다. 
- 문제는 프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못한다는 데 있다. 
- 리팩터링은 코드가 더 잘 읽히게 도와준다. 리팩터링을 하면 코드의 목적이 더 잘 드러나게, 다시 말해 내 의도를 더 명확하게 전달하도록 개선할 수 있다.

- 코드를 보면 알 수 있는 것들은 의도적으로 기억하지 않는다. 기억할 필요가 있는 것들은 최대한 코드에 담으려 한다. 

<br>

#### 🎈 리팩터링하면 버그를 쉽게 찾을 수 있다. 

<br>

- 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다. 
- 리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다. 
- 프로그램의 구조를 명확하게 다듬으면 그냥 '이럴 것이다'라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도까지 명확해진다. 
- 리팩터링은 견고한 코드를 작성하는 데 무척 효과적이다. 

<br>

#### 🎈 리팩터링하면 프로그래밍 속도를 높일 수 있다.

<br>

- 리팩터링하면 코드 개발 속도를 높일 수 있다. 
- 내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 품질 향상에 직결된다. 
- 새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다. 
- 기능을 추가하고 나면 버그가 발생하는 일이 잦고, 이를 해결하는 시간은 한층 더 걸린다. 
- 코드베이스는 패치에 패치가 덧붙여지면서 프로그램의 동작을 파악하기가 거의 고대 유적 발굴만큼 어려워진다.

<br>

- 내부 설계가 잘 된 소프트웨어는 새로운 기능이 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다. 
- 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다. 
- 코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다. 
- 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다. 

##### 설계 지구력 가설 
- 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다. 
- 리팩터링하면 기존 코드의 설계를 얼마든지 개선할 수 있으므로, 설령 프로그램 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다. 
- 처음부터 좋은 설계를 마련하기란 매우 어렵다. 그래서 빠른 개발이라는 숭고한 목표를 달성하려면 리팩터링이 반드시 필요하다.






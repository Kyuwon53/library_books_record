# 📚 REFACTORING : 리팩터링 2판
## 📖 2장 리펙터링 원칙 🔎

<br>

### 📍 1 리팩터링 정의

<br>

> 리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

- **함수 추출하기**와 **조건부 로직을 다형성으로 바꾸기**처럼 이름 붙은 리팩터링 기법들이 이 정의에 해당한다. 

> 리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성한다. 

- 지금껏 수많은 사람이 코드를 정리하는 작업을 모조리 `리펙터링`이라고 표현하고 있는데, 앞에서 제시한 정의를 따르면 **특정한 방식에 따라 코드를 정리하는 것**만이 리팩터링이다. 
- 리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다. 
- 개별 리팩터링은 그 자체로 아주 작을 수도 있고, 작은 단계 여러 개가 합쳐진 모습일 수도 있다. 
- 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다. 

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

- 코드베이스를 정리하거나 구조를 바꾸는 모든 작업을 `재구성(restructuring)`이라는 포괄적인 용어로 표현하고, 리팩터링은 재구성 중 특수한 한 형태로 본다. 
- 한 번에 바꿀 수 있는 작업을 수많은 단계로 잘게 나눠서 작업하는 모습을 처음 접하면 리팩터링하는 것이 오히려 비효율적이라고 생각하기 쉽다. 하지만 이렇게 잘게 나눔으로써 오히려 작업을 더 빨리 처리할 수 있다. 
- 단계들이 체계적으로 구성되어 있기도 하고, 무엇보다 디버깅하는 데 시간을 뺏기지 않기 때문이다. 

<br>

- 리팩터링을 정의할 때 `겉보기 동작`이란 표현을 썼다. 리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다는 뜻이다. 완전히 똑같다는 말은 아니다.
- 사용자 관점에서는 달라지는 점이 없어야 한다. 
- 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다. (단, 아무도 발견하지 못한 숨은 버그는 수정해도 괜찮다)
- 리팩터링은 성능 최적화와 비슷하다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다. 단지 목적이 다를 뿐.
- 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 

<br>

### 📍 2 두 개의 모자

<br>

- 기능을 추가할 때는 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 
- 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정한다. 
- 리팩토링할 때는 가능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다. 
- (앞 과정에서 놓친 테스트 케이스를 발견하지 않는 한) 테스트도 새로 만들지 않는다. 부득이 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다. 

- 새 기능을 추가하다 보면 코드 구조를 바꿔야 작업하기 훨씬 쉽겠다는 생각이 들기도 하는데, 리펙토링을 한다. 
- 코드 구조가 어느 정도 개성되면 다시 기능 추가를 이어간다. 
- 추가한 기능이 제대로 작동하는지까지 확인했다면 작성한 코드를 살펴본다. 
- 코드가 이해하기 어렵게 짜였다면 다시 모자를 바꿔 쓰고 리팩토링한다. 
- 전체 작업 시간이 10분 정도로 짧다 해도, 항상 내가 하고 있는 작업이 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다. 

<br>

### 📍 3 리팩터링하는 이유

<br>

- 리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 절대 아니다. 하지만 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다. 

<br>

#### 🎈 리팩터링하면 소프트웨어 설계가 좋아진다. 

<br>

- 리팩터링하지 않으면 소프트웨어의 내부 설계(아키텍처)가 썩기 쉽다. 
- 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.
  - 그러면 코드만 봐서는 설계를 파악하기 어려워진다. 
  - 코드 구조가 무너지기 시작하면 악효과가 누적된다. 
- 코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고, 설계가 부패되는 속도는 더욱 빨라진다.
- 반면 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다. 

<br>

- 중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다. 
- 코드량을 줄인다고 시스템이 빨라지는 것은 아니다. 프로그램의 용량이 속도에 영향을 주는 경우는 별로 없다.
- 코드량이 줄면 수정하는 데 드는 노력은 크게 달라진다.
  - 코드가 길수록 실수 없이 수정하기 어려워진다. 
  - 이해햐야 할 코드량도 늘어난다. 
  - 비슷한 일을 하는 코드가 산재해 있다면 한 부분만 살짝 바꿔서는 시스템이 예상대로 작동하지 않을 수 있다. 
- 중복 코들르 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며, 이는 바람직한 설계의 핵심이다. 

<br>

#### 🎈 리팩터링하면 소프트웨어를 이해하기 쉬워진다. 

<br>

- 프로그래밍은 컴퓨터와 대화하는 것과 같다. 컴퓨터에게 시킬 일을 표현하는 코드를 작성하면, 컴퓨터는 정확히 시킨 대로 반응한다.
- 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 한다. 
- 프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일이다. 
- 문제는 프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못한다는 데 있다. 
- 리팩터링은 코드가 더 잘 읽히게 도와준다. 리팩터링을 하면 코드의 목적이 더 잘 드러나게, 다시 말해 내 의도를 더 명확하게 전달하도록 개선할 수 있다.

- 코드를 보면 알 수 있는 것들은 의도적으로 기억하지 않는다. 기억할 필요가 있는 것들은 최대한 코드에 담으려 한다. 

<br>

#### 🎈 리팩터링하면 버그를 쉽게 찾을 수 있다. 

<br>

- 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다. 
- 리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다. 
- 프로그램의 구조를 명확하게 다듬으면 그냥 '이럴 것이다'라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도까지 명확해진다. 
- 리팩터링은 견고한 코드를 작성하는 데 무척 효과적이다. 

<br>

#### 🎈 리팩터링하면 프로그래밍 속도를 높일 수 있다.

<br>

- 리팩터링하면 코드 개발 속도를 높일 수 있다. 
- 내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 품질 향상에 직결된다. 
- 새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다. 
- 기능을 추가하고 나면 버그가 발생하는 일이 잦고, 이를 해결하는 시간은 한층 더 걸린다. 
- 코드베이스는 패치에 패치가 덧붙여지면서 프로그램의 동작을 파악하기가 거의 고대 유적 발굴만큼 어려워진다.

<br>

- 내부 설계가 잘 된 소프트웨어는 새로운 기능이 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다. 
- 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다. 
- 코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다. 
- 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다. 

##### 설계 지구력 가설 
- 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다. 
- 리팩터링하면 기존 코드의 설계를 얼마든지 개선할 수 있으므로, 설령 프로그램 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다. 
- 처음부터 좋은 설계를 마련하기란 매우 어렵다. 그래서 빠른 개발이라는 숭고한 목표를 달성하려면 리팩터링이 반드시 필요하다.

<br>

### 📍 4 언제 리팩터링해야 할까?

<br>

#### < 3의 법칙 > _ 돈 로버츠
>   
> 1. 처음에는 그냥 한다. 
> 2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다. 
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.
>   

<br>

#### 🎈 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

<br>

- 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 
- 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다. 
- 복사해서 붙여넣는 방식으로 처리하면 나중에 새 기능을 약간 변형한 버전을 만들어야 할 때 번거로울 수 있다.
- 그래서 이럴 때는 리팩터링 모자를 쓰고 **함수 매개변수화하기**를 적용한다. 
- 그러고 나면 그 함수에 필요한 매개변수를 지정해서 호출하기만 하면 된다. 

<br>

> 비유하면 지금 위치에서 동쪽으로 100km를 이동하려는데 그 사이를 숲이 가로막고 있다면, 좀 둘러가더라도 20km 북쪽에 있는 고속도로를 타는 편이 세 배나 빠를 수 있다. 다들 "직진!"을 외치더라도, 때로는 "잠깐, 지도를 보고 가장 빠른 경로를 찾아보자"고 말할 줄 알아야 한다. 준비를 위한 리팩터링이 바로 이런 역할을 한다. 

<br>

- 버그를 잡을 때도 마찬가지다. 오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면, 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편하다.
- 또는 질의 코드에 섞여 있는 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 크게 줄일 수 있다. 
- 준비를 위한 리팩터링으로 상황을 개선해놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에, 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수도 있다. 

<br>

#### 🎈 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기 

<br>

- 코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다. 
- 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다. 
- 조건부 로직의 구조가 이상하지 않은지 살펴보기도 하고, 함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지는 않는지도 살펴본다. 

<br>

- 리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다. 
- 그런 다음 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인 할 수 있다. 
- 내가 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라 동료들도 알 수 있다. 

- 어떤 역할을 하는지 이해된 변수는 적절한 이름으로 바꿔주고, 긴 함수를 잘게 나누기도 한다. 
- 그러면 코드가 깔끔하게 정리되어 전에는 보이지 않던 설계가 눈에 들어오기 시작한다. 
- 코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다. 

<br>

#### 🎈 쓰레기 줍기 리팩터링

<br>

- 코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다. 
- 로직이 쓸데없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있다. 
- 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.
- 이것이 이해를 위한 리팩터링의 변형인 **쓰레기 줍기 리팩터링**이다. 

- 물론 수정하려면 몇 시간이나 걸리고 당장은 더 급한 일이 있을 수 있다. 그렇더라도 조금이나마 개선해두는 것이 좋다. 
- 항상 처음 봤을 때보다 깔끔하게 정리하고 떠나자. 
- 리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨뜨리지 않는다는 사실이다. 
- 작업을 잘게 나누면 몇 달에 걸쳐 진행하더라도 그 사이 한 순간도 코드가 깨지지 않기도 한다. 

<br>

#### 🎈 계획된 리팩터링과 수시로 하는 리팩터링

<br>

- 준비를 위한 리책터링, 이해를 위한 리팩터링, 쓰레기 줍기 리팩터링은 모두 기회가 될 때만 진행한다. 
- 리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다. 
- 프로그래밍 과정에 자연스럽게 녹인 것이다. 
- 리팩터링은 눈앞의 문제뿐 아니라 앞으로 할 작업에도 도움을 준다. 
- 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다. 
- 리팩터링 시간을 일정에 따로 잡아두지 않고, 대부분의 리팩터링을 다른 일을 하는 중에 처리한다. 

<br>

> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다. 

<br>

- 리팩터링은 과거에 저지른 실수를 바로잡거나 보기 싫은 코드를 정리하는 작업이라고 오해하기 쉽다. 
- 보기 싫은 코드를 보면 리팩터링해야 함은 당연하지만, 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다. 

<br>

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그런 다음 쉽게 수정하자

<br>

- 오랫동안 사람들은 소프트웨어 개발이란 뭐가 '추가'하는 과정으로 여겼다. 기능을 추가하다 보면 대개 새로운 코드를 작성해 넣게 된다. 
- 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 **'수정'**하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다. 
- 그동안 리팩터링에 소홀했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있다. 
- 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다. 

<br>

- 리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많기 때문에 리팩터링 커밋과 기능 추가 커밋을 나누는 것은 시간 낭비일 수 있다.
- 또한 해당 리팩터링을 하게 된 맥락 정보가 사라져서 왜 그렇게 수정했는지 이해하기 어려워진다. 
- 리팩터링 커밋을 분리한다고 해서 무조건 좋은 것은 아님을 명시하고, 팀에 적합한 방식을 실험을 통해 찾아내야 한다. 

<br>

#### 🎈 오래 걸리는 리팩터링

<br>

- 라이브러리를 새 것으로 교체하는 작업일 수도 있고, 일부 코드를 다른 팀과 공유하기 위해 컴포넌트로 빼내는 작업일 수도 있다. 또는 그동안 작업하면서 쌓여온 골치 아픈 의존성을 정리하는 작업일 수도 있다. 
- 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다. 
- 누구든지 리팩터링해야할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식이다. 
- 리팩터링이 코드를 깨트리지 않는다는 장점을 활용하는 것이다. 
- 일부를 변경해도 모든 기능이 항상 올바르게 동작한다. 
- 라이브러리를 교체할 때는 기존 것과 새 것 모두를 포용하는 추상 인터페이스부터 마련한다. 
- 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다. 

<br>

#### 🎈 코드 리뷰에 리팩터링 활용하기 

<br>

- 코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다. 경험이 더 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있다. 
- 대규모 소프트웨어 시스템의 다양한 측면을 더 많은 사람이 이해하는 데도 도움된다. 
- 깔끔한 코드를 작성하는 데에도 굉장히 중요하다.
- 코드 리뷰를 하면 다른 사람의 아이디어를 얻을 수 있다는 장점도 있다.
- 리팩터링은 다른 이의 코드를 리뷰하는 데도 도움된다. 
- 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현해넣을 수 있는지부터 살펴본다. 쉽다면 실제로 리팩터링한다.
- 이 과정을 몇 번 반복하면 내가 떠올린 아이디어를 실제로 적용했을 때의 모습을 더 명확하게 볼 수 있다. 

<br>

- 리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움된다. 
- 개선안들을 제시하는 데서 그치지 않고, 그중 상당수를 즉시 구현해볼 수 있기 때문이다. 
- 코드 리뷰에 리팩터링을 접목하는 구체적인 방법은 리뷰의 성격에 따라 다르다. 
- 흔히 쓰는 풀 요청 모델(pull request model)(코드 작성자 없이 검토하는 방식)에서는 그리 효과적이지 않다. 
- 코드 작성자가 참석해야 맥락을 설명해줄 수 있고 작성자도 리뷰어의 변경 의도를 제대로 이해할 수 있으므로, 이왕이면 참석자가 참석하는 방식이 좋다. 
- 가장 좋은 방법은 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링하는 것이다. 이렇게 하면 자연스럽게 (프로그래밍 과정 안에 지속적인 코드 리뷰가 녹아 있는) **짝 프로그래밍**이 된다. 

<br>

#### 🎈 관리자에게는 뭐라고 말해야 할까?

<br>

- 프로 개발자의 역할은 효과적인 소프트웨어를 최대한 빨리 만드는 것이다. 
- 내 경험상 리팩터링하면 소프트웨어를 빠르게 만드는 데 아주 효과적이다. 
- 새 함수를 추가하려는데 현재 설계가 적합하지 않다면 먼저 리팩터링하고 나서 함수를 추가하는 편이 빠르다. 
- 버그를 수정하려면 현재 소프트웨어의 작동 방식을 이해해야 한다. 이때도 리팩터링부터 하는 편이 가장 빠르다.
- 프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다. 그래서 리팩터링부터 한다. 

<br>

#### 🎈 리팩터링하지 말아야 할 때 

<br>

- 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 않는다. 
- 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다. 
- 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다. 
- 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다. 
- 리팩터링할지 새로 작성할지를 잘 결정하려면 뛰어난 판단력과 경험이 뒷받침돼야 한다. 

<br>

### 📍 5 리팩터링 시 고려할 문제

<br>

- 리팩터링이 많은 팀에서 적극적으로 도입해야 할 중요한 기법이라 믿는다. 
- 하지만 리팩터링에 딸려 오는 문제도 엄연히 있기에, 이런 문제가 언제 발생하고 어떻게 대처해야 할지를 반드시 알고 있어야 한다. 

<br>

#### 🎈 새 기능 개발 속도 저하

<br>

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다. 

- 상황에 맞게 조율해야 한다. 리팩터링이 필요해 보이지만, 추가하려는 새 기능이 아주 작아서 기능 추가부터 하고 싶은 상황에 마주칠 수 있다. 경험을 잘 발휘해서 결정한다. 
- 준비를 위한 리팩터링을 하면 변경을 훨씬 쉽게 할 수 있다고 확신한다. 
- 새 기능을 구현해넣기 편해지겠다 싶은 리팩터링이라면 주저하지 않고 리팩터링부터 한다. 
- 한번 본 문제일 때도 리팩터링부터 하는 편이다
-  건강한 코드의 위력을 충분히 경험해보지 않고서는 코드베이스가 건강할 때와 허약할 때의 생산성 차이를 체감하기 어렵다. 
- 코드베이스가 건강하면 기존 코드를 새로운 방식으로 조합하기 쉬워서 복잡한 새 기능을 더 빨리 추가할 수 있다. 

<br>

- 사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 '클린 코드'나 '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 정당화하는 것이다. 
- 리팩터링의 본질은 코드베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 경제적인 이유로 하는 것이다. 
- **리팩터링은 개발 기간을 단축하고자 하는 것이다. 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다.**
- 리팩터링하도록 이끄는 동력은 어디까지나 경제적인 효과에 있다. 

<br>

#### 🎈 코드 소유권

<br>

- 리팩터링하다 보면 모듈의 내부뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많다.
- 코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 클라이언트에 영향을 주지 않고서는 원하는 형태로 변경할 수 없기 때문이다. 
- 함수 이름을 변경할 떄는 함수 이름 바꾸기를 적용하는 한편, 기존 함수도 그대로 유지하되 함수 본문에서 새 함수를 호출하도록 수정한다. 
- 인터페이스는 복잡해지지만 클라이언트에 영향을 주지 않기 위해서는 어쩔 수 없다. 

<br>

- 코드 소유권을 작은 단위로 나눠 엄격히 관리하는 데 반대한다. 
- 코드베이스에서 곧바로 수정하면 훨씬 간단할 일을 계속해서 인터페이스를 관리하느라 시달리는 결과를 초래한다. 
- 코드의 소유권을 팀에 두어 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 한다. 
- 프로그래머마다 각자가 책임지는 영역이 있을 수는 있다. 자신이 맡은 영역의 변경 사항을 관리하라는 뜻이지, 다른 사람이 수정하지 못하게 막으라는 뜻이 아니다. 

<br>

- 코드 소유권을 느슨하게 정하는 방식은 여러 팀으로 구성된 조직에도 적용할 수 있다. 
- 변경 사항 커밋을 클라이언트를 관리하는 쪽에서 승인하면 기존 함수를 삭제할 수 있다. 
- 이 방식은 코드 소유권을 엄격히 제한하는 방식과 완전히 풀어서 변경을 통제하기 어려운 방식을 절충한 것으로, 대규모 시스템 개발 시 잘 어울린다. 

<br>

#### 🎈 브랜치

<br>

- 현재 흔히 볼 수 있는 팀 작업 방식은 버전 관리 시스템을 사용하여 팀원마다 코드베이스의 브랜치를 하나씩 맡아서 작업하다가, 결과물이 어느 정도 쌓이면 마스터 브랜치에 통합해서 다른 팀원과 공유하는 것이다. 
- 이렇게 하면 어떤 기능 전체를 한 브랜치에만 구현해놓고, 프로덕션 버전으로 릴리스할 때가 돼서야 마스터에 통합하는 경우가 많다. 
- 단점: 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다. 
- 마스터를 개인 브랜치로 수시로 리베이스하거나 머지한다. 하지만 여러 기능 브랜치에서 동시에 개발이 진행될 때는 이런 식으로 해결할 수 없다. 
- 머지와 통합을 명확히 구분한다. 마스터를 브랜치로 **'머지'**하는 작업은 단방향이다. 브랜치만 바뀌고 마스터는 그대로다. 
- **'통합'**은 마스터를 개인 브랜치로 가져와서(pull) 작업한 결과를 다시 마스터에 올리는(push) 양방향 처리를 뜻한다. 그래서 마스터와 브랜치가 모두 변경된다. 

<br>

- 누군가 개인 브랜치에서 작업한 내용을 마스터에 통합하기 전까지는 다른 사람이 그 내용을 볼 수 없다. 
- 머지가 복잡해지는 문제는 기능별 브랜치들이 독립적으로 개발되는 기간이 길어질수록 기하급수적으로 늘어난다. 
- 기능별 브랜치의 통합 주기를 짧게 관리하는 것을 지속적 통합(CI), 또는 트렁크 기반 개발(TBD)라 한다. 
- CI에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다. 
- 이렇게 하면 다른 브랜치들과의 차이가 크게 벌어지는 브랜치가 없어져서 머지의 복잡도를 상당히 낮출 수 있다. 
- 마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글(기능 플래그)을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 한다. 

<br>

#### 🎈 테스팅

<br>

- 리팩터링의 두드러진 특성은 프로그램의 겉보기 동작은 똑같이 유지된다는 것이다. 
- 절차를 지켜 제대로 리팩터링하면 동작이 깨지지 않아야 한다. 
- 리팩터링은 단계별 변경 폭이 작아서 도중에 발생한 오류의 원인이 될만한 코드 범위가 넓지 않다. 
- 핵심은 오류를 재빨리 잡는 데 있다. 실제로 이렇게 하려면 코드의 다양한 측면을 검사하는 테스트 스위트가 필요하다. 
- 리팩터링하기 위해서는 (대부분의 경우에) 자가 테스트 코드를 마련해야 한다는 뜻이다. 

<br>

- 자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다. 실수로 만든 버그를 빠르게 찾아서 제거할 수 있기 때문이다. 
- 핵심은 테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다는 데 있다. 
- 테스트 주기가 짧다면 단 몇 줄만 비교하면 되며, 문제를 일으킨 부분이 그 몇 줄 안에 있기 때문에 버그를 훨씬 쉽게 찾을 수 있다. 
- 자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 CI와도 밀접하게 연관된다. 
- CI에 통합된 테스트는 XP의 권장사항이자 지속적 배포(CD)의 핵심이기도 하다. 

<br>

#### 🎈 레거시 코드

<br>

- 레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다. 
- 제 기능과 맞지 않은 함수 이름을 바로 잡고 어설픈 프로그램 구문을 매끄럽게 다듬어서 거친 원석 같던 프로그램을 반짝이는 보석으로 만들 수 있다. 
- 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다. 
- 이 문제의 정답은 당연히 **테스트 보강**이다. 보통은 테스트를 염두에 두고 설게한 시스템만 쉽게 테스트할 수 있다. 
- `프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다`는 것이다. 틈새를 만들 때 리팩터링이 활용된다.
- 테스트 없이 진행하기 때문에 상당히 위험하지만 문제를 해결하기 위해서라면 감내해야 할 위험이다. 
- 테스트를 갖추고 있더라도 복잡하게 얽힌 레거시 코드를 아름다운 코드로 단번에 리팩터링하는 데는 낙관적이지 않다. 
- 서로 관련된 부분끼리 나눠서 하나씩 공략하는 것이 좋다. 
- 레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다. 

<br>

#### 🎈 데이터베이스 

<br>

- 진화형 데이터베이스 설계와 데이터베이스 리팩터링 기법
  - 핵심은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다. 
- 전체 변경 과정을 작고 독립된 단계들로 쪼개는 것이 핵심이다. 그래야 마이그레이션 후에도 정상 작동할 수 있다.
- 단계를 잘게 나누면 코드도 쉽게 작성할 수 있다. 여러 단계를 순차적으로 연결해서 데이터베이스의 구조와 그 안에 담긴 데이터를 큰 폭으로 변경할 수도 있다. 
- 데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다. 
- 이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽다. 
  1. 필드 이름을 바꿀 때 첫 번째 커밋에서는 새로운 데이터베이스 필드를 추가만 하고 사용하지는 않는다. 
  2. 기존 필드와 새 필드를 동시에 업데이트하도록 설정한다. 
  3. 데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체한다. 
  4. 이 과정에서 발생하는 버그도 해결하면서 클라이언트 교체 작업을 모두 끝냈다면, 더는 필요가 없어진 예전 필드를 삭제한다. 

  




